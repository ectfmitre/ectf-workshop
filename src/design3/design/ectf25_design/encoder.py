"""
This source file is part of an example system for MITRE's 2025 Embedded System
CTF (eCTF).
The encoder module is responsible for encrypting/signing frames using channel
keys found in the provided secrets data.
"""

import argparse
import pickle
from Crypto.Cipher import ChaCha20_Poly1305
from Crypto.PublicKey import ECC
from Crypto.Random import get_random_bytes
from Crypto.Random import random
from Crypto.Signature import eddsa

def RandomSalt(min_length: int, max_length: int) -> bytes:
	n = random.randint(min_length, max_length)
	return n.to_bytes(1) + get_random_bytes(n)

class Encoder:
	def __init__(self, secrets: bytes):
		"""
		You **may not** change the arguments or returns of this function!

		:param secrets: Contents of the secrets file generated by
			ectf25_design.gen_secrets
		"""
		secret_data = pickle.loads(secrets)
		self.raw_symmetric_channel_keys = {}
		self.private_channel_keys = {}
		for channel_id, raw_keys in secret_data['channel_keys'].items():
			self.raw_symmetric_channel_keys[channel_id] = raw_keys['symmetric']
			self.private_channel_keys[channel_id] = ECC.import_key(raw_keys['private'])


	def encode(self, channel: int, frame: bytes, timestamp: int) -> bytes:
		"""The frame encoder function

		This will be called for every frame that needs to be encoded before being
		transmitted by the satellite to all listening TVs

		You **may not** change the arguments or returns of this function!

		:param channel: 32b unsigned channel number. Channel 0 is the emergency
			broadcast that must be decodable by all channels.
		:param frame: Frame to encode. Max frame size is 64 bytes.
		:param timestamp: 64b timestamp to use for encoding. **NOTE**: This value may
			have no relation to the current timestamp, so you should not compare it
			against the current time. The timestamp is guaranteed to strictly
			monotonically increase (always go up) with subsequent calls to encode

		:returns: The encoded frame, which will be sent to the Decoder
		"""
		frame_len = len(frame)
		nonce = get_random_bytes(12)
		private_key = self.private_channel_keys[channel]
		chacha_key = ChaCha20_Poly1305.new(key=self.raw_symmetric_channel_keys[channel], nonce=nonce)
		
		payload = b''
		payload += channel.to_bytes(4, 'little')
		payload += timestamp.to_bytes(8, 'little')
		payload += frame_len.to_bytes(1)
		payload += frame
		signature = eddsa.new(private_key, 'rfc8032').sign(payload)
		salted_signed_payload = RandomSalt(7, 25) + payload + signature
		# pad to multiple of 16 bytes
		salted_signed_payload += get_random_bytes((16 - len(salted_signed_payload) % 16) % 16)
		ciphertext, tag = chacha_key.encrypt_and_digest(salted_signed_payload)
		return channel.to_bytes(4, 'little') + nonce + ciphertext + tag


def main():
	"""A test main to one-shot encode a frame

	This function is only for your convenience and will not be used in the final design.

	After pip-installing, you should be able to call this with:
		python3 -m ectf25_design.encoder path/to/test.secrets 1 "frame to encode" 100
	"""
	parser = argparse.ArgumentParser(prog="ectf25_design.encoder")
	parser.add_argument(
		"secrets_file", type=argparse.FileType("rb"), help="Path to the secrets file"
	)
	parser.add_argument("channel", type=int, help="Channel to encode for")
	parser.add_argument("frame", help="Contents of the frame")
	parser.add_argument("timestamp", type=int, help="64b timestamp to use")
	args = parser.parse_args()

	encoder = Encoder(args.secrets_file.read())
	print(repr(encoder.encode(args.channel, args.frame.encode(), args.timestamp)))


if __name__ == "__main__":
	main()
