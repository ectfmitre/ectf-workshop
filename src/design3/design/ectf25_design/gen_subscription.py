"""
This source file is part of an example system for MITRE's 2025 Embedded System
CTF (eCTF). 
The gen_subscription module packs the given subscription data
with the channels keys (symmetric and public) for the given channel and
signs/encrypts using the device-specific subscription keys (private and
symmetric). The subscription keys are generated deterministically from a
secret seed and the device ID via hashing.
"""

import argparse
import pickle
from Crypto.Cipher import ChaCha20_Poly1305
from Crypto.Hash import BLAKE2b
from Crypto.Hash import SHA3_256
from Crypto.PublicKey import ECC
from Crypto.Random import get_random_bytes
from Crypto.Random import random
from Crypto.Signature import eddsa
from loguru import logger
from pathlib import Path

def GenerateDeterministicSymmetricKeyRaw(sub_seed: bytes, device_id: int) -> bytes:
	blake2b = BLAKE2b.new(digest_bits=256)
	blake2b.update(device_id.to_bytes(4) + sub_seed)
	return blake2b.digest()

def GenerateDeterministicECCKey(sub_seed: bytes, device_id: int):
	sha3_256 = SHA3_256.new()
	sha3_256.update(device_id.to_bytes(4) + sub_seed)
	ecc_seed = sha3_256.digest()
	return ECC.construct(curve='ed25519', seed=ecc_seed)

def RandomSalt(min_length: int, max_length: int) -> bytes:
	n = random.randint(min_length, max_length)
	return n.to_bytes(1) + get_random_bytes(n)

def gen_subscription(
	secrets: bytes, device_id: int, start: int, end: int, channel: int
) -> bytes:
	"""Generate the contents of a subscription.

	The output of this will be passed to the Decoder using ectf25.tv.subscribe

	:param secrets: Contents of the secrets file generated by ectf25_design.gen_secrets
	:param device_id: Device ID of the Decoder
	:param start: First timestamp the subscription is valid for
	:param end: Last timestamp the subscription is valid for
	:param channel: Channel to enable
	"""
	secret_data = pickle.loads(secrets)
	channel_keys = secret_data['channel_keys'][channel]
	channel_symmetric_key_raw = channel_keys['symmetric']
	channel_public_key_raw = channel_keys['public']
	subscription_seed = secret_data['sub_seed']
	subscription_priv_key = GenerateDeterministicECCKey(subscription_seed, device_id)
	subscription_symmetric_key_raw = GenerateDeterministicSymmetricKeyRaw(subscription_seed, device_id)
	assert len(channel_symmetric_key_raw) == 32
	assert len(channel_public_key_raw) == 32

	payload = b''
	payload += channel_symmetric_key_raw
	payload += channel_public_key_raw
	payload += device_id.to_bytes(4, 'little')
	payload += start.to_bytes(8, 'little')
	payload += end.to_bytes(8, 'little')
	payload += channel.to_bytes(4, 'little')
	signature = eddsa.new(subscription_priv_key, 'rfc8032').sign(payload)
	salted_signed_payload = RandomSalt(7, 22) + payload + signature
	# pad to multiple of 16 bytes
	salted_signed_payload += get_random_bytes((16 - len(salted_signed_payload) % 16) % 16)

	nonce = get_random_bytes(12)
	subscription_chacha_key = ChaCha20_Poly1305.new(key=subscription_symmetric_key_raw, nonce=nonce)
	ciphertext, tag = subscription_chacha_key.encrypt_and_digest(salted_signed_payload)
	return nonce + ciphertext + tag


def parse_args():
	"""Define and parse the command line arguments

	NOTE: Your design must not change this function
	"""
	parser = argparse.ArgumentParser()
	parser.add_argument(
		"--force",
		"-f",
		action="store_true",
		help="Force creation of subscription file, overwriting existing file",
	)
	parser.add_argument(
		"secrets_file",
		type=argparse.FileType("rb"),
		help="Path to the secrets file created by ectf25_design.gen_secrets",
	)
	parser.add_argument("subscription_file", type=Path, help="Subscription output")
	parser.add_argument(
		"device_id", type=lambda x: int(x, 0), help="Device ID of the update recipient."
	)
	parser.add_argument(
		"start", type=lambda x: int(x, 0), help="Subscription start timestamp"
	)
	parser.add_argument("end", type=int, help="Subscription end timestamp")
	parser.add_argument("channel", type=int, help="Channel to subscribe to")
	return parser.parse_args()


def main():
	"""Main function of gen_subscription

	You will likely not have to change this function
	"""
	# Parse the command line arguments
	args = parse_args()

	subscription = gen_subscription(
		args.secrets_file.read(), args.device_id, args.start, args.end, args.channel
	)

	# Print the generated subscription for your own debugging
	# Attackers will NOT have access to the output of this (although they may have
	# subscriptions in certain scenarios), but feel free to remove
	#
	# NOTE: Printing sensitive data is generally not good security practice
	logger.debug(f"Generated subscription: {subscription}")

	# Open the file, erroring if the file exists unless the --force arg is provided
	with open(args.subscription_file, "wb" if args.force else "xb") as f:
		f.write(subscription)

	# For your own debugging. Feel free to remove
	logger.success(f"Wrote subscription to {str(args.subscription_file.absolute())}")


if __name__ == "__main__":
	main()
